name: CI/CD

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master]
  release:
    types: [published]

env:
  JAVA_VERSION: '21'
  CLOJURE_VERSION: '1.11.1.1413'

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'clojure'
      
      - name: Install Clojure tools
        uses: DeLaGuardo/setup-clojure@12.5
        with:
          cli: ${{ env.CLOJURE_VERSION }}
      
      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
            ~/.gitlibs
          key: ${{ runner.os }}-clojure-${{ hashFiles('**/deps.edn') }}
          restore-keys: |
            ${{ runner.os }}-clojure-
      
      - name: Download dependencies
        run: clojure -P -M:dev:test:poly
      
      - name: Run Polylith checks
        run: clojure -M:poly check
      
      - name: Run tests
        run: clojure -M:poly test :dev
      
      - name: Lint with clj-kondo
        run: |
          curl -sLO https://raw.githubusercontent.com/clj-kondo/clj-kondo/master/script/install-clj-kondo
          chmod +x install-clj-kondo
          ./install-clj-kondo
          clj-kondo --lint components bases --parallel
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: target/test-results/

  build:
    name: Build
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'release'
    
    outputs:
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'clojure'
      
      - name: Install Clojure tools
        uses: DeLaGuardo/setup-clojure@12.5
        with:
          cli: ${{ env.CLOJURE_VERSION }}
      
      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
            ~/.gitlibs
          key: ${{ runner.os }}-clojure-${{ hashFiles('**/deps.edn') }}
      
      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="$(git rev-parse --short HEAD)"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"
      
      - name: Build uberjar
        run: clojure -T:build uberjar
      
      - name: Verify build
        run: |
          ls -lh target/simplicity-standalone.jar
          java -jar target/simplicity-standalone.jar --version || true
      
      - name: Upload uberjar artifact
        uses: actions/upload-artifact@v4
        with:
          name: simplicity-uberjar-${{ steps.version.outputs.version }}
          path: target/simplicity-standalone.jar
          retention-days: 30

  docker:
    name: Build and Push Docker Image
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'release'
    
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
      
      - name: Generate deployment summary
        run: |
          echo "## Docker Image Published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:**" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Pull command:**" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "docker pull $(echo '${{ steps.meta.outputs.tags }}' | head -n1)" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  deploy-staging:
    name: Deploy to Staging
    needs: [build, docker]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment:
      name: staging
      url: https://staging.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download deployment script
        run: |
          chmod +x scripts/deploy.sh
      
      - name: Deploy to staging
        env:
          SSH_PRIVATE_KEY: ${{ secrets.STAGING_SSH_KEY }}
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_USER: ${{ secrets.STAGING_USER }}
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "$STAGING_HOST" >> ~/.ssh/known_hosts
          
          # Deploy via SSH
          ssh -i ~/.ssh/deploy_key "$STAGING_USER@$STAGING_HOST" << 'ENDSSH'
            cd /opt/simplicity
            
            # Pull latest image
            docker pull ghcr.io/${{ github.repository }}:develop
            
            # Deploy with zero-downtime script
            ARTIFACT_TYPE=docker \
            HEALTH_URL=http://localhost:3000/health \
            ./scripts/deploy.sh deploy ghcr.io/${{ github.repository }}:develop
          ENDSSH
      
      - name: Verify deployment
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
        run: |
          sleep 10
          curl -f https://staging.example.com/health || exit 1

  deploy-production:
    name: Deploy to Production
    needs: [build, docker]
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    environment:
      name: production
      url: https://app.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download deployment script
        run: |
          chmod +x scripts/deploy.sh
      
      - name: Deploy to production
        env:
          SSH_PRIVATE_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "$PRODUCTION_HOST" >> ~/.ssh/known_hosts
          
          # Deploy via SSH
          ssh -i ~/.ssh/deploy_key "$PRODUCTION_USER@$PRODUCTION_HOST" << 'ENDSSH'
            cd /opt/simplicity
            
            # Pull release image
            docker pull ghcr.io/${{ github.repository }}:${{ github.event.release.tag_name }}
            
            # Deploy with zero-downtime script
            ARTIFACT_TYPE=docker \
            HEALTH_URL=http://localhost:3000/health \
            LOG_LEVEL=WARN \
            ENABLE_HSTS=true \
            ./scripts/deploy.sh deploy ghcr.io/${{ github.repository }}:${{ github.event.release.tag_name }}
          ENDSSH
      
      - name: Verify deployment
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
        run: |
          sleep 10
          curl -f https://app.example.com/health || exit 1
      
      - name: Create deployment summary
        run: |
          echo "## Production Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ github.event.release.tag_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** https://app.example.com" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_STEP_SUMMARY

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
