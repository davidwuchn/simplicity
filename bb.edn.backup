{:min-bb-version "1.0.0"
 
 :paths ["scripts"]
 
 :deps {babashka/fs {:mvn/version "0.5.30"}
        babashka/process {:mvn/version "0.6.25"}}
 
 :tasks
 {;; Suppress warnings for overriding built-in commands (repl, help, uberjar)
  :override-builtin true
  
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ;; Development Tasks
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
   dev
   {:doc "Start development REPL with hot reload"
    :task (shell "clojure -M:nrepl")}
   
   nrepl
   {:doc "Start Babashka nREPL server on port 7888"
    :task (shell "bb nrepl-server 7888")}
   

  
  check
  {:doc "Check Polylith workspace integrity"
   :task (shell "clojure -M:poly check")}
  
  info
  {:doc "Show Polylith workspace info"
   :task (shell "clojure -M:poly info")}
  
  diff
  {:doc "Show changed bricks in workspace"
   :task (shell "clojure -M:poly diff")}
  
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ;; Testing Tasks
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
   test
   {:doc "Run all tests"
    :task (shell "clojure -M:poly test :dev")}
  
  test:watch
  {:doc "Run tests in watch mode (re-run on file changes)"
   :requires ([babashka.fs :as fs]
              [babashka.process :as p])
   :task (do
           (println "Watching for file changes...")
           (println "Press Ctrl+C to stop")
           (loop [last-modified 0]
             (let [current-modified (->> (fs/glob "." "**/*.clj")
                                         (map fs/last-modified-time)
                                         (apply max)
                                         inst-ms)]
               (when (> current-modified last-modified)
                 (println "\nâ•â•â• Running tests â•â•â•")
                 (try
                   (shell "clojure -M:poly test :dev")
                   (catch Exception e
                     (println "Test failed:" (ex-message e)))))
               (Thread/sleep 2000)
               (recur current-modified))))}
  
  test:auth
  {:doc "Run auth component tests"
   :task (shell "clojure -M:test -e \"(require 'cc.mindward.auth.interface-test 'cc.mindward.auth.documentation-test) (clojure.test/run-tests 'cc.mindward.auth.interface-test 'cc.mindward.auth.documentation-test)\"")}
  
  test:game
  {:doc "Run game component tests"
   :task (shell "clojure -M:test -e \"(require 'cc.mindward.game.interface-test) (clojure.test/run-tests 'cc.mindward.game.interface-test)\"")}
  
  test:ui
  {:doc "Run UI component tests"
   :task (shell "clojure -M:test -e \"(require 'cc.mindward.ui.core-test 'cc.mindward.ui.components-test 'cc.mindward.ui.helpers-test) (clojure.test/run-tests 'cc.mindward.ui.core-test 'cc.mindward.ui.components-test 'cc.mindward.ui.helpers-test)\"")}
  
  test:user
  {:doc "Run user component tests"
   :task (shell "clojure -M:test -e \"(require 'cc.mindward.user.interface-test 'cc.mindward.user.security-test) (clojure.test/run-tests 'cc.mindward.user.interface-test 'cc.mindward.user.security-test)\"")}
  
  test:web-server
  {:doc "Run web-server base tests"
   :task (shell "clojure -M:test -e \"(require 'cc.mindward.web-server.core-test 'cc.mindward.web-server.security-test) (clojure.test/run-tests 'cc.mindward.web-server.core-test 'cc.mindward.web-server.security-test)\"")}
  
  test:property
  {:doc "Run property-based tests"
   :task (shell "clojure -M:test -e \"(require 'cc.mindward.game.property-test) (clojure.test/run-tests 'cc.mindward.game.property-test)\"")}
  
  test:performance
  {:doc "Run performance tests"
   :task (shell "clojure -M:test -e \"(require 'cc.mindward.game.performance-test) (clojure.test/run-tests 'cc.mindward.game.performance-test)\"")}
  
  test:documentation
  {:doc "Run documentation contract tests"
   :task (shell "clojure -M:test -e \"(require 'cc.mindward.auth.documentation-test) (clojure.test/run-tests 'cc.mindward.auth.documentation-test)\"")}
  
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ;; Linting & Formatting Tasks
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
   lint
   {:doc "Lint all source files with clj-kondo"
    :task (shell "clj-kondo --lint components/auth/src components/game/src components/ui/src components/user/src bases/web-server/src development/src")}
  
   lint:fix
   {:doc "Auto-fix linting issues where possible"
    :task (shell "clj-kondo --lint components/auth/src components/game/src components/ui/src components/user/src bases/web-server/src development/src --auto-fix")}
  
  format:check
  {:doc "Check code formatting (requires cljfmt)"
   :task (shell "clojure -M:format check")}
  
  format:fix
  {:doc "Fix code formatting (requires cljfmt)"
   :task (shell "clojure -M:format fix")}
  
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ;; Build Tasks
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  clean
  {:doc "Clean build artifacts"
   :requires ([babashka.fs :as fs])
   :task (do
           (println "Cleaning build artifacts...")
           (when (fs/exists? "target")
             (fs/delete-tree "target")
             (println "âœ“ Deleted target/"))
           (when (fs/exists? "simplicity.db")
             (fs/delete "simplicity.db")
             (println "âœ“ Deleted simplicity.db"))
           (when (fs/exists? ".nrepl-port")
             (fs/delete ".nrepl-port")
             (println "âœ“ Deleted .nrepl-port"))
           (println "Clean complete."))}
  
  uberjar
  {:doc "Build standalone uberjar (45MB)"
   :task (do
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println "  Building Simplicity Uberjar")
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (shell "clojure -T:build uberjar")
           (println "\nâœ“ Build complete!")
           (println "\nRun with:")
           (println "  java -jar target/simplicity-standalone.jar"))}
  
  jar-info
  {:doc "Show information about built jar"
   :task (shell "clojure -T:build jar-info")}
  
  build
  {:doc "Full build: clean + test + uberjar"
   :depends [clean test uberjar]
   :task (println "\nâœ“ Full build complete!")}
  
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ;; Docker Tasks
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  docker:build
  {:doc "Build Docker image"
   :requires ([clojure.string :as str])
   :task (let [version (str/trim (slurp "VERSION" :encoding "utf-8"))]
           (println (str "Building Docker image: simplicity:" version))
           (shell (str "docker build -t simplicity:" version " -t simplicity:latest ."))
           (println (str "\nâœ“ Docker image built: simplicity:" version)))}
  
  docker:run
  {:doc "Run Docker container locally"
   :task (do
           (println "Starting Simplicity in Docker...")
           (println "Access at: http://localhost:3000")
           (shell "docker run -p 3000:3000 -v $(pwd)/data:/app/data simplicity:latest"))}
  
  docker:compose
  {:doc "Start with Docker Compose (with volumes)"
   :task (shell "docker-compose up -d")}
  
  docker:compose:down
  {:doc "Stop Docker Compose"
   :task (shell "docker-compose down")}
  
  docker:compose:logs
  {:doc "View Docker Compose logs"
   :task (shell "docker-compose logs -f")}
  
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ;; Deployment Tasks
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  deploy:build
  {:doc "Interactive build menu for deployment"
   :task (shell "./scripts/build-deployment.sh")}
  
  deploy:health
  {:doc "Monitor production health endpoint"
   :task (shell "./scripts/health-monitor.sh")}
  
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ;; Database Tasks
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  db:reset
  {:doc "Reset local development database"
   :requires ([babashka.fs :as fs])
   :task (do
           (println "Resetting development database...")
           (when (fs/exists? "simplicity.db")
             (fs/delete "simplicity.db")
             (println "âœ“ Deleted simplicity.db"))
           (println "Database will be recreated on next server start."))}
  
  db:backup
  {:doc "Backup production database"
   :requires ([babashka.fs :as fs]
              [java-time.local :as t])
   :task (let [timestamp (.format (t/local-date-time) "yyyyMMdd-HHmmss")
               backup-file (str "backups/simplicity-" timestamp ".db")]
           (fs/create-dirs "backups")
           (fs/copy "simplicity.db" backup-file)
           (println (str "âœ“ Database backed up to: " backup-file)))}
  
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ;; Utility Tasks
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  ver
  {:doc "Show project version"
   :task (print (slurp "VERSION"))}
  
  ver:bump
  {:doc "Bump version (patch)"
   :requires ([clojure.string :as str])
   :task (let [current (str/trim (slurp "VERSION"))
               parts (str/split current (re-pattern "\\."))
               major (first parts)
               minor (second parts)
               patch (parse-long (nth parts 2))
               new-version (str major "." minor "." (inc patch))]
           (spit "VERSION" (str new-version "\n"))
           (println (str "Version bumped: " current " â†’ " new-version)))}
  
  health
  {:doc "Check local server health"
   :task (shell "curl -s http://localhost:3000/health | jq")}
  
  stats
  {:doc "Show project statistics"
   :requires ([babashka.process :as p]
              [babashka.fs :as fs])
   :task (let [clj-files (count (fs/glob "." "**/*.clj"))
               test-files (count (fs/glob "." "**/*_test.clj"))
               src-files (- clj-files test-files)]
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println "  Simplicity Project Statistics")
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println (str "Source files:     " src-files))
           (println (str "Test files:       " test-files))
           (println (str "Total files:      " clj-files))
           (println (str "Components:       4 (auth, game, ui, user)"))
           (println (str "Bases:            1 (web-server)"))
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"))}
  
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ;; MEMENTUM Tasks - Git Memory System
  ;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  memory:store
  {:doc "Store a critical insight or decision (Î» store)"
   :requires ([clojure.string :as str]
              [babashka.fs :as fs]
              [java-time.local :as t])
   :task (do
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println "  MEMENTUM: Store Critical Memory")
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println "\nSymbols:")
           (println "  ğŸ§ ğŸ’¡ insight  - Novel architectural insight")
           (println "  ğŸ”„Î” pattern-shift  - Significant pattern shift")
           (println "  ğŸ¯âš¡ decision  - Strategic decision (>1 week impact)")
           (println "  ğŸŒ€ meta  - Meta-learning that changes approach")
           (print "\nEnter symbol (e.g., insight): ")
           (flush)
           (let [symbol (read-line)
                 valid-symbols #{"insight" "pattern-shift" "decision" "meta"}
                 _ (when-not (valid-symbols symbol)
                     (println (str "Invalid symbol. Must be one of: " (str/join ", " valid-symbols)))
                     (System/exit 1))
                 date (.format (t/local-date) "yyyy-MM-dd")
                 (print "Enter slug (short description, kebab-case): ")
                 (flush)
                 slug (read-line)
                 filename (str "memories/" symbol "-" date "-" slug ".md")
                 (print "Enter memory content (â‰¤200 tokens, press Ctrl+D when done):\n")
                 (flush)
                 content (slurp *in*)
                 token-count (count (str/split content (re-pattern "\\s+")))]
             (when (> token-count 200)
               (println (str "Warning: Memory exceeds 200 tokens (" token-count "). Compress ruthlessly.")))
             (fs/create-dirs "memories")
             (spit filename content)
             (println (str "\nâœ“ Memory saved to: " filename))
             (println "\nTo commit:")
             (println (str "  git add " filename))
             (println (str "  git commit -m \"" symbol " " slug "\""))))}
  
  memory:recall
  {:doc "Recall memories (Î» recall)"
   :task (do
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println "  MEMENTUM: Recall Memories")
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println "\nUsage examples:")
           (println "  bb memory:recall --recent 2")
           (println "  bb memory:recall --search \"architecture\"")
           (println "  bb memory:recall --symbol insight")
           (println "\nDefault: Shows recent 2 memories (Fibonacci n-1, n-2)"))}
  
  memory:recall:recent
  {:doc "Show recent memories (default n=2)"
   :task (shell "git log -n 2 -- memories/")}
  
  memory:recall:search
  {:doc "Search memories by content"
   :task (do
           (print "Enter search query: ")
           (flush)
           (let [query (read-line)]
             (shell (str "git grep -i \"" query "\" memories/"))))}
  
  memory:recall:symbol
  {:doc "Search memories by symbol"
   :task (do
           (print "Enter symbol (insight|pattern-shift|decision|meta): ")
           (flush)
           (let [symbol (read-line)]
             (shell (str "git log --grep \"" symbol "\" -- memories/"))))}
  
  memory:ooda
  {:doc "Run MEMENTUM OODA loop"
   :task (do
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println "  MEMENTUM OODA Loop")
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println "\n1. OBSERVE (recent context):")
           (shell "git log -n 13 -- memories/")
           (println "\n2. ORIENT (search for patterns):")
           (print "Enter search query for orientation: ")
           (flush)
           (let [query (read-line)]
             (shell (str "git grep -i \"" query "\" memories/")))
           (println "\n3. DECIDE (create/update memory)")
           (println "4. ACT (git commit)")
           (println "\nRun 'bb memory:store' to create a new memory."))}
  
  memory:stats
  {:doc "Show MEMENTUM statistics"
   :requires ([babashka.fs :as fs])
   :task (let [memory-files (fs/glob "memories" "*.md")
               memory-count (count memory-files)
               symbols (->> memory-files
                           (map (fn [f] (first (str/split (fs/file-name f) (re-pattern "-")))))
                           frequencies
                           (sort-by val >))]
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println "  MEMENTUM Statistics")
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
           (println (str "Total memories: " memory-count))
           (println "\nBy symbol:")
           (doseq [[symbol count] symbols]
             (println (str "  " symbol ": " count " memories")))
           (println "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")))}
  
   help
   {:doc "Show all available tasks"
    :task (shell "bb tasks")}}}
